!! +exec+ +var+ +string+
$lst_tit replace$lst_titend$type_both
  $(lst_syntax)replace [internal] $emph s1 $emphend by $emph s2 $emphend in $emph
  string$emphend<br/>
  </tt>or <tt>!replace $emph obj$emphend $emph ident$emphend by
  $emph s$emphend in $emph string$emphend</tt>
  $lst_mean String manipulation. <p>
  Under the first syntax, variable substitution is first done on 
  $emph string$emphend. Then all occurences of substring $emph s1$emphend 
  are replaced by $emph s2$emphend. <br/>
  When the keyword $emph internal $emphend is absent,
  the Linux utility $emph sed$emphend is called to make the replacements,
  therefore regular expressions are accepted in $emph s1$emphend and 
  $emph s2$emphend. Please refer to the man page of $emph sed$emphend for 
  details. </p><p>
  Under the second syntax, $emph obj$emphend can be $emph char$emphend,
  $emph word$emphend,
  $emph item$emphend or $emph line$emphend. Then the word, item or line
  identified by $emph ident$emphend in $emph string$emphend is replaced 
  by $emph s$emphend, after variable substitutions. <br/>
  $emph ident$emphend can be a string, in this case all objects 
  (words, items or lines) matching
  $emph ident$emphend will be replaced. It can also be a number (positive or
  negative integer $emph n$emphend), preceded
  by the word $emph number$emphend. In this case the object
  number $emph n$emphend will be replaced. (In the case where n&lt;0,
  it is the last -n'th object which is replaced.)
  </p>
