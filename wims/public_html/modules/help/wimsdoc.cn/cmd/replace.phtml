!! +exec+ +var+ +string+
$lst_tit replace$lst_titend$type_both
  $(lst_syntax)replace [internal] $emph s1 $emphend by $emph s2 $emphend in $emph
  string$emphend<br>
  </tt>或 <tt>!replace $emph obj$emphend $emph ident$emphend by
  $emph s$emphend in $emph string$emphend</tt> <br>
  $lst_mean 串操作. <p>
  在第一句的形式下, 先对.
  然后所有出现子串 $emph s1$emphend 的地方都替换成 $emph s2$emphend. <br>
  如果没有关键词 $emph internal $emphend,
  则调用 Linux 命令 $emph sed$emphend 完成替换,
  所以在 $emph s1$emphend 和 $emph s2$emphend 里可接受正则表达式.
  详情请参看 $emph sed$emphend 的说明. <p>
  在第二句的形式下, $emph obj$emphend 可以是 $emph char$emphend,
  $emph word$emphend, $emph item$emphend 或 $emph line$emphend. 
  经过对 $emph string$emphend 作变量替换后,
  $emph string$emphend 内与 $emph ident$emphend 相同的词、项或行被替代为
  $emph s$emphend. <br>
  $emph ident$emphend 可以是一个串, 此时所有与 $emph ident$emphend 匹配的对象
  (词、项或行)将被替换. $emph ident$emphend 也可以是一个数(正或负整数 $emph n$emphend),
  前面冠以词 $emph number$emphend. 这时被替换的是第 $emph n$emphend 个对象
  (当 n&lt;0 时, 被替换的是倒数第 $emph n$emphend 个对象.)
  


